# Merge Game
Небольшая игра в жанре Merge. Вы должны перемещать появляющеися фигуры на панеле, соеденять их и тем самым повышать их уровень. 
<a href="https://imgbb.com/"><img src="https://i.ibb.co/DKXhTqt/2024-04-17-062639.png" alt="2024-04-17-062639" border="0"></a>

<a href="https://ibb.co/sq0B5hg"><img src="https://i.ibb.co/qptZ0zD/gif-animation-009.gif" alt="gif-animation-009" border="0"></a>

------------

#### В игре есть 2 режима игры:

### Стандартный:
Панель 3x3, новые фигуры появляются каждые 2 секунды. 
### Расширенный:
Панель 6x6 новые фигуры появляются каждые 1.5 секунды. Кроме того в расширенном режиме есть ещё новые фигуры, которые отличаются своей функциональностью, а именно:
#### Монетка
<a href="https://ibb.co/ggXfG9q"><img src="https://i.ibb.co/6spT2w9/gif-animation-011.gif" alt="gif-animation-011" border="0"></a>

Вы сможете подобрать её и увеличить ваше количество монеток.
#### Стена
<a href="https://ibb.co/Hd2DpNv"><img src="https://i.ibb.co/DpbDgGX/gif-animation-012.gif" alt="gif-animation-012" border="0"></a>

Будет иногда появляться на поле, убрать нельзя. При попытке нажать на неё, будет дёргаться.

## Техническая часть
### Zenject
Из глобальных решений в проекте используется Zenject для внедрения зависимостей. Так же у Zenject есть встроенные реализации фабрик. + есть реализация паттерна SignalBus, что позволит управлять глобальными событиями. 

Сама установка зависимостей в игре начинается с класса GameRoot. Там прописана большая часть биндинга для наших классов. Биндинги которые нужны только для наших фигру (фигуры=все объекты на панеле) происходят в GameObjectContext в префабах самих фигур. Далее в классе GameStarter создаётся сетка и начинается спавн объектов.

###Фигуры
Сами фигуры это MonoBehaviour классы, они наследуются от абстрактной Figure и реалзуют какие-то свои базовые действия. Есть так же 2 интерфейса которые декларируют что в целом могут делать наши фигуры (IHoldable, ITakeble). [Интерфейс IHoldable реализует 2 метода Hold и Place т.к мы предпологаем, что любой объект который мы взяли, мы сможем положить.] Ну и есть класс Graber2D который через клик мышки управляет нашими фигурами через эти интерфейсы. В будущем можно будет использовать эти интерфейсы для чего-то ещё. Если действия фигуры сложны или в теории могут повторяться реализованы стратегии IHoldStrategy, IPlaceStrategy в будущем можно добавить ITakeStrategy. На самом деле сложных поведений кроме MergeFigure в игре нету, поэтому только там эти стратегии используются, но в теоретическом будущем опять же, желательно будет использовать их везде.
###Сетка и ячейки
Есть Cell MonoBehaviour класс который мы часто получаем через нажатие мыши, у него есть модель CellModel в которой хранится Figure. У CellModel есть методы для принятия фигуры [Методы разделены на принятие просто Figure и на преобразование IHoldable объекта в Figure т.к мы можем ставить фигуры или из вне как в случае со спавнером так и с помощью перемещения фигуры IHoldable] и есть методы для отпускания фигуры или её уничтожения. Ну и Grid Generator который эти ячейки генерирует.
###Спавн фигур и тип игры
Есть перечисление, мы задаём его значение через переход на сцену и на основе него ставим параметры игры. Можно очень легко менять объекты которые спавнятся, размер сетки и скорость спавна. Например мы можем очень просто сделать бонусный уровень, оставив в спавне только монетки.
###Анимации
Есть базовый AnimtaionTween, от него наследуются анимации. В настройках тех же фигур можно выставить какую анимацию мы хотим[enum] и её параметры. Есть так же фабрика, которая создаёт нам анимацию которую мы выберем. Это позволяет очень легко менять анимации даже не залезая в код.
###Кошелёк
Есть модель кошелька и его View которая отрисовывает текущее золото, уведомление о изменении золота сделано через встроенный в Zenject SignalBus.
###Переход через сцены
Простенький MonoBehaviour класс который имеет публичные методы, которые вызываются через Doozy ui кнопки. На самом деле в новых версиях Doozy есть встроенный инструмен для перехода на другие сцены.

